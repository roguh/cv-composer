// Generated by CoffeeScript 1.9.2
var add_all, c, camera, camera_far, clear_scene, container, controls, i, j, k, l, len, len1, lines, m, max, obj, points, r2, r2_canvas, r2_points, r2_resolution, r2_stage, r2_texture, r3_points, read_input_matrix, redraw, ref, ref1, ref2, render, renderer, s, s2, s2_points, scene, show_r2, show_r3, show_s2, t, theta, transform, write_input_matrix, x, y;

if (!Detector.webgl) {
  Detector.addGetWebGLMessage;
}

container = document.getElementById('vis');

scene = new THREE.Scene;

scene.fog = new THREE.FogExp2(0xffffff, 0.002);

camera_far = 10000;

camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, camera_far);

renderer = new THREE.WebGLRenderer({
  antialias: true
});

renderer.setSize(container.offsetWidth, container.offsetHeight);

renderer.setClearColor(scene.fog.color, 1);

renderer.setPixelRatio(window.devicePixelRatio);

container.appendChild(renderer.domElement);

window.addEventListener('resize', function() {
  camera.aspect = container.offsetWidth / container.offsetHeight;
  camera.updateProjectionMatrix();
  return renderer.setSize(container.offsetWidth, container.offsetHeight);
});

r2_canvas = document.createElement('canvas');

r2_resolution = 1024;

r2_canvas.width = r2_canvas.height = r2_resolution;

r2_stage = new createjs.Stage(r2_canvas);

make_plane(root_objects, 2, 0xbbffbb);

s2 = make_point(s2_points, 2, 0x101010, 1.0, 50);

r2_texture = new THREE.Texture(r2_canvas);

r2_texture.needsUpdate = true;

r2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({
  side: THREE.DoubleSide,
  map: r2_texture,
  transparent: true
}));

r2.position.z = 1;

max = 10;

for (i = j = ref = -max, ref1 = max; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
  r2_stage.addChild(canvas_line([i / max, 1], [i / max, -1], 0x222222, 1));
  r2_stage.addChild(canvas_line([1, i / max], [-1, i / max], 0x222222, 1));
}

scene.add(new THREE.AmbientLight(0x404040));

scene.add(new THREE.HemisphereLight(0xffffff, 0x404040, 1));

for (k = 0, len = root_objects.length; k < len; k++) {
  obj = root_objects[k];
  scene.add(obj);
}

x = y = 0.1;

theta = PI / 4;

c = Math.cos(theta);

s = Math.sin(theta);

m = new THREE.Matrix3().set(c, 0.1, x, 0, s, y, 0, 0.4, 1);

t = function(m, p) {
  return array2_from_vec3(vec3_from_array(p).applyMatrix3(m));
};

points = [
  {
    'p': [0, 0],
    'c': 0xff0000
  }, {
    'p': [0.5, 0.5],
    'c': 0xff00f0
  }, {
    'p': [-0.4, 0.6],
    'c': 0xfff000
  }
];

lines = [
  {
    'p1': [0.2, 0.2],
    'p2': [-0.3, 0.4],
    'c': 0xaa0ff
  }, {
    'p1': [-0.2, -0.1],
    'p2': [0, 0.1],
    'c': 0xff0aa
  }
];

r2_points = new Array();

s2_points = new Array();

r3_points = new Array();

clear_scene = function() {
  var l, len1, len2, n, ref2;
  ref2 = r3_points.concat(s2_points);
  for (l = 0, len1 = ref2.length; l < len1; l++) {
    obj = ref2[l];
    scene.remove(obj);
  }
  scene.remove(r2);
  for (n = 0, len2 = r2_points.length; n < len2; n++) {
    obj = r2_points[n];
    r2_stage.removeChild(obj);
  }
  r2_stage.update();
  r2.material.map.needsUpdate = true;
  r2_points = new Array();
  s2_points = new Array();
  return r3_points = new Array();
};

add_all = function(m, show_r2, show_s2, show_r3) {
  var l, len1, len2, len3, len4, len5, n, o, p, q, u;
  if (show_r2 == null) {
    show_r2 = true;
  }
  if (show_s2 == null) {
    show_s2 = true;
  }
  if (show_r3 == null) {
    show_r3 = true;
  }
  for (l = 0, len1 = points.length; l < len1; l++) {
    p = points[l];
    make_p_point(t(m, p.p), p.c);
  }
  for (n = 0, len2 = lines.length; n < len2; n++) {
    p = lines[n];
    make_p_line(t(m, p.p1), t(m, p.p2), p.c, 1.0, true);
  }
  if (show_r3) {
    for (o = 0, len3 = r3_points.length; o < len3; o++) {
      obj = r3_points[o];
      scene.add(obj);
    }
  }
  if (show_s2) {
    for (q = 0, len4 = s2_points.length; q < len4; q++) {
      obj = s2_points[q];
      scene.add(obj);
    }
  }
  if (show_r2) {
    scene.add(r2);
    for (u = 0, len5 = r2_points.length; u < len5; u++) {
      obj = r2_points[u];
      r2_stage.addChild(obj);
    }
  }
  r2_stage.update();
  return r2.material.map.needsUpdate = true;
};

transform = new THREE.Matrix3();

show_r2 = show_s2 = show_r3 = true;

redraw = function() {
  clear_scene();
  return add_all(transform, show_r2, show_s2, show_r3);
};

camera.position.z = 2;

theta = -PI * 3 / 4;

camera.position.y = 3 * Math.sin(theta);

camera.position.x = 3 * Math.cos(theta);

controls = new THREE.OrbitControls(camera, renderer.domElement);

controls.enableDamping = true;

controls.dampingFactor = 1.0;

controls.enablePan = false;

render = function() {
  requestAnimationFrame(render);
  renderer.render(scene, camera);
  return controls.update();
};

write_input_matrix = function(m, dim, id_prefix) {
  var l, r, ref2, results;
  if (dim == null) {
    dim = 3;
  }
  if (id_prefix == null) {
    id_prefix = "input#trans_";
  }
  results = [];
  for (r = l = 1, ref2 = dim; 1 <= ref2 ? l <= ref2 : l >= ref2; r = 1 <= ref2 ? ++l : --l) {
    results.push((function() {
      var n, ref3, results1;
      results1 = [];
      for (c = n = 1, ref3 = dim; 1 <= ref3 ? n <= ref3 : n >= ref3; c = 1 <= ref3 ? ++n : --n) {
        results1.push($(id_prefix + ('' + r) + ('' + c)).val(m.elements[(c - 1) * dim + (r - 1)]));
      }
      return results1;
    })());
  }
  return results;
};

read_input_matrix = function(dim, id_prefix) {
  var a, l, n, r, ref2, ref3;
  if (dim == null) {
    dim = 3;
  }
  if (id_prefix == null) {
    id_prefix = "input#trans_";
  }
  a = Array(dim * dim);
  for (r = l = 1, ref2 = dim; 1 <= ref2 ? l <= ref2 : l >= ref2; r = 1 <= ref2 ? ++l : --l) {
    for (c = n = 1, ref3 = dim; 1 <= ref3 ? n <= ref3 : n >= ref3; c = 1 <= ref3 ? ++n : --n) {
      a[(c - 1) * dim + (r - 1)] = parseFloat($(id_prefix + ('' + r) + ('' + c)).val());
    }
  }
  return new THREE.Matrix3().fromArray(a);
};

ref2 = [
  {
    'checkbox': 'input#show_r2',
    'f': function() {
      show_r2 = this.checked;
      return redraw();
    }
  }, {
    'checkbox': 'input#show_s2',
    'f': function() {
      show_s2 = this.checked;
      return redraw();
    }
  }, {
    'checkbox': 'input#show_r3',
    'f': function() {
      show_r3 = this.checked;
      return redraw();
    }
  }
];
for (l = 0, len1 = ref2.length; l < len1; l++) {
  c = ref2[l];
  $(c.checkbox).prop('checked', true).change(c.f);
}

$('button#apply_trans').click(function() {
  transform = read_input_matrix();
  return redraw();
});

$('button#create_sim').click(function() {
  var prefix, tx, ty;
  prefix = 'input#sim_';
  s = parseFloat($(prefix + 's').val());
  theta = parseFloat($(prefix + 'theta').val());
  theta = PI * theta / 180;
  tx = parseFloat($(prefix + 'tx').val());
  ty = parseFloat($(prefix + 'ty').val());
  m = new THREE.Matrix3().set(s * Math.cos(theta), -s * Math.sin(theta), tx, s * Math.sin(theta), s * Math.cos(theta), ty, 0, 0, 1);
  return write_input_matrix(m);
});

$('button#add_point').click(function() {
  x = parseFloat($('input#point_x').val());
  y = parseFloat($('input#point_y').val());
  points.push({
    'p': [x, y],
    'c': 0
  });
  return redraw();
});

$('button#add_line').click(function() {
  var a, b;
  a = parseFloat($('input#line_a').val());
  b = parseFloat($('input#line_b').val());
  c = parseFloat($('input#line_c').val());
  lines.push({
    'p1': [0, -c / b],
    'p2': [-c / a, 0],
    'c': 0
  });
  return redraw();
});

$('button#clear_all').click(function() {
  lines = [];
  points = [];
  return clear_scene();
});

redraw();

render();

//# sourceMappingURL=vis.js.map
