// Generated by CoffeeScript 1.9.2
var PI, add_to, array2_from_vec3, canvas_line, ctx_color, ctx_coords, extend, make_line, make_p_line, make_p_point, make_plane, make_point, r2_points, r3_points, root_objects, s2_points, vec2, vec2_from_array, vec3, vec3_from_array;

ctx_coords = function(xy, f) {
  var ref, x, y;
  ref = xy instanceof THREE.Vector3 || xy instanceof THREE.Vector2 ? [xy.x, xy.y] : xy, x = ref[0], y = ref[1];
  return f(r2_resolution / 2 * (x + 1), r2_resolution / 2 * (1 - y));
};

ctx_color = function(c) {
  if (!(c instanceof String || typeof c === "string")) {
    c = c.toString(16);
  }
  return '#' + ('000000' + c).substring(c.length);
};

canvas_line = function(p1, p2, color, width, collection) {
  var c;
  if (collection == null) {
    collection = [];
  }
  color = ctx_color(color);
  c = ctx_coords(p1, function(x, y) {
    return (new createjs.Shape()).set({
      x: x,
      y: y
    });
  });
  ctx_coords(p1, function(x1, y1) {
    return ctx_coords(p2, function(x2, y2) {
      return c.graphics.beginStroke(color).setStrokeStyle(width).moveTo(0, 0).lineTo(x2 - x1, y2 - y1);
    });
  });
  return add_to(collection, c);
};

PI = Math.PI;

vec2 = function(x, y) {
  return new THREE.Vector2(x, y);
};

vec3 = function(x, y, z) {
  return new THREE.Vector3(x, y, z);
};

array2_from_vec3 = function(v) {
  return (v instanceof THREE.Vector3 ? [v.x / v.z, v.y / v.z, 1] : v);
};

vec3_from_array = function(p) {
  return (p instanceof THREE.Vector3 ? p : vec3(p[0], p[1], p.length > 2 ? p[2] : 1));
};

vec2_from_array = function(p) {
  return (p instanceof THREE.Vector2 ? p : vec2(p[0], p[1]));
};

add_to = function(c, o) {
  c.push(o);
  return o;
};

r2_points = [];

s2_points = [];

r3_points = [];

root_objects = [];

extend = function(v1, v2, length) {
  var v1_orig;
  if (length == null) {
    length = camera_far;
  }
  v1_orig = v1.clone();
  v1.sub(v2);
  v1.setLength(length);
  v1.add(v2);
  v2.sub(v1_orig);
  v2.setLength(length);
  v2.add(v1_orig);
  return [v1, v2];
};

make_point = function(collection, size, color, opacity, detail) {
  if (opacity == null) {
    opacity = 1.0;
  }
  if (detail == null) {
    detail = 15;
  }
  return add_to(collection, new THREE.Mesh(new THREE.SphereGeometry(size, detail, detail), new THREE.MeshLambertMaterial({
    color: color,
    transparent: opacity !== 1.0,
    opacity: opacity
  })));
};

make_plane = function(collection, size, color, opacity) {
  if (opacity == null) {
    opacity = 1.0;
  }
  return add_to(collection, new THREE.Mesh(new THREE.PlaneGeometry(size, size), new THREE.MeshBasicMaterial({
    color: color,
    side: THREE.DoubleSide,
    transparent: opacity !== 1.0,
    opacity: opacity
  })));
};

make_line = function(collection, here, there, color, width, extend_vectors) {
  var geometry, ref, v1, v2;
  if (width == null) {
    width = 1;
  }
  if (extend_vectors == null) {
    extend_vectors = true;
  }
  v1 = vec3_from_array(here);
  v2 = vec3_from_array(there);
  if (extend_vectors) {
    ref = extend(v1, v2), v1 = ref[0], v2 = ref[1];
  }
  geometry = new THREE.Geometry;
  geometry.vertices.push(v1, v2);
  return add_to(collection, new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  })));
};

make_p_point = function(p, color) {
  var c, o1, o2, o3;
  p = vec2_from_array(p);
  c = add_to(r2_points, ctx_coords(p, function(x, y) {
    return (new createjs.Shape()).set({
      x: x,
      y: y
    });
  }));
  c.graphics.beginFill(ctx_color(color)).drawCircle(0, 0, 4);
  o1 = make_line(r3_points, [-p.x, -p.y, -1], [p.x, p.y, 1], color);
  o2 = make_point(s2_points, 0.015, color);
  o2.position.copy(vec3(p.x, p.y, 1).normalize());
  o3 = make_point(s2_points, 0.015, color);
  o3.position.copy(vec3(-p.x, -p.y, -1).normalize());
  return {
    r2: [c],
    s2: [o2, o3],
    r3: [o1]
  };
};

make_p_line = function(p1, p2, color, opacity, draw_points) {
  var _p1, _p2, angle, c, o, ref, v1, v2;
  if (opacity == null) {
    opacity = 1.0;
  }
  if (draw_points == null) {
    draw_points = false;
  }
  ref = [vec2_from_array(p1), vec2_from_array(p2)], p1 = ref[0], p2 = ref[1];
  c = canvas_line(p1, p2, color, 3, r2_points);
  _p1 = _p2 = [];
  if (draw_points) {
    _p1 = make_p_point(p1, color);
    _p2 = make_p_point(p2, color);
  }
  o = make_plane(r3_points, 3, color, opacity);
  v1 = vec3(p1.x, p1.y, 1);
  v2 = vec3(p2.x, p2.y, 1);
  v1.cross(v2);
  v1.normalize();
  angle = v1.angleTo(vec3(0, 0, 1));
  o.rotation.setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(vec3(0, 0, 1), v1));
  return {
    r2: _p1.r2.concat(_p2.r2).concat(c),
    s2: _p1.s2.concat(_p2.s2),
    r3: _p1.r3.concat(_p2.r3).concat([o])
  };
};

//# sourceMappingURL=util.js.map
